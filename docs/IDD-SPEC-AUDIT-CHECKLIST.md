# IDD Spec Audit Checklist

**Purpose:** Validate the IDD specification against the as-built `amplifier-bundle-idd` implementation.
**Spec version:** v0.4 (amplifier-idd-spec3.docx)
**Original spec audit date:** 2026-02-18
**Post-implementation review date:** 2026-02-18
**Auditors:** amplifier:amplifier-expert, foundation:foundation-expert, core:core-expert

---

## Verdict: PASS (with architectural evolution)

The spec was approved and implemented as `amplifier-bundle-idd`. During
implementation, the architecture evolved from the spec's proposed custom
orchestrator to a **tool + hooks** design on the standard `loop-streaming`
orchestrator. This is a pragmatic improvement aligned with Amplifier philosophy
(mechanism, not policy; ruthless simplicity). All spec items that remain
applicable pass. Items that assumed the custom orchestrator have been retired
and replaced with documentation of the actual architecture.

**Totals: 11 PASS, 5 DEFERRED, 1 PARTIALLY ADDRESSED**

### Architecture

The implementation uses two LLM-callable tools and four lifecycle hooks on
the standard `loop-streaming` orchestrator. There is no custom IDD orchestrator.

| Component | Type | Purpose |
|-----------|------|---------|
| `idd_decompose` | Tool | Decomposes natural language into five IDD primitives via LLM |
| `idd_compile` | Tool | Compiles a `Decomposition` into an Amplifier recipe YAML |
| `hooks-idd-grammar-inject` | Hook (priority 3) | Injects Grammar state into LLM context each turn (ephemeral) |
| `hooks-idd-confirmation` | Hook (priority 7) | Non-blocking timed confirmation gate |
| `hooks-idd-events` | Hook (priority 10) | Records all `idd:*` events to in-memory log |
| `hooks-idd-reporter` | Hook (priority 15) | Renders human-readable progress messages |

**Capabilities registered:**

| Capability | Registered By | Purpose |
|------------|--------------|---------|
| `idd.grammar_state` | `IDDDecomposeTool` | Mutable `GrammarState` shared across tools and hooks |
| `idd.event_log` | `hooks-idd-events` | In-memory event list (capped at 2000) for observability |

---

## P0 — Must Pass (Blocks Everything)

### P0-1: No coordinator.mount("agents") Misuse — PASS

Zero uses of `coordinator.mount("agents")` in any source file. Tools register via
`coordinator.mount("tools", ...)`. Agents are included declaratively via
`behaviors/idd-core.yaml`. The standard orchestrator and delegate tool handle
agent spawning.

- [x] **P0-1a:** All references to `coordinator.mount("agents", ...)` removed. Confirmed by grep — zero hits in source code.
- [x] **P0-1b:** Tools register via `coordinator.mount("tools", decompose_tool, name=...)` and `coordinator.mount("tools", compile_tool, name=...)` in `__init__.py`.
- [x] **P0-1c:** Agents included declaratively in `behaviors/idd-core.yaml` via `agents: include:` references.

---

### P0-2: Recipe Compilation Pipeline — PASS

The compiler transforms `Decomposition` dataclass instances into Amplifier recipe
YAML. Input is natural language (not structured markdown as the spec originally
assumed). The pipeline is:

```
NL string -> LLM -> JSON -> Decomposition dataclass -> YAML recipe dict
```

- [x] **P0-2a:** Compilation pipeline implemented in `compiler.py`. Takes a `Decomposition`, produces a recipe dict or YAML string.
- [x] **P0-2b:** `{{steps.X.result}}` template expressions implemented via `_context_refs()`.
- [x] **P0-2c:** `depends_on` chaining implemented via sequential group ordering.
- [x] **P0-2d:** Parallel execution implemented via heuristic detection (`_detect_parallelism`) of parallel keywords in agent instructions.
- [x] **P0-2e:** Approval gates implemented as recipe-level `approval:` block when `trigger.confirmation == "human"`.

**Known limitations:**

- `foreach` loops and `while_condition`/`break_when` convergence loops are not generated by the compiler. These features are available in the recipe schema but require hand-authored recipes.
- The compiler generates flat `steps` lists, not staged recipes. Hand-authored recipes in `recipes/` demonstrate staged patterns with per-stage approvals.
- Input is plain NL text, not structured IDD markdown. The spec's side-by-side markdown/YAML examples remain useful as documentation but do not describe the actual code path.

---

### P0-3: Behaviors vs. Hooks Distinction — PASS

The conceptual distinction between behaviors (convention bundles, Grammar layer) and
hooks (Python code, Machinery layer) is correctly maintained in the implementation.

- [x] **P0-3a:** Hooks are Python modules: `hooks-idd-events/`, `hooks-idd-grammar-inject/`, `hooks-idd-reporter/`, `hooks-idd-confirmation/`. Each has a `mount()` function, registers on coordinator lifecycle events, and returns `HookResult`.
- [x] **P0-3b:** The behavior is `behaviors/idd-core.yaml` — a YAML file per Foundation convention (not `.md` as the spec originally listed). It wires tools, hooks, agents, and context declaratively.

---

## P1 — Should Pass Before Implementation

### P1-1: Agent Definition Format — PASS

All three agents use correct Amplifier agent format with `meta:` frontmatter.

- [x] **P1-1a:** `idd-composer.md`, `idd-reviewer.md`, and `idd-spec-expert.md` all use `meta:` frontmatter with `name:` and `description:`.
- [x] **P1-1b:** Agents are loaded via `agents: include:` in `behaviors/idd-core.yaml` using the `idd:agents/` namespace prefix.

**Note:** The spec proposed `## Capabilities` and `## Constraints` sections for
semantic agent matching during dynamic composition. These were not implemented.
The parser resolves agents by name only — agent names from
`coordinator.config["agents"]` are presented to the LLM, which infers capability
from names. This is sufficient for current usage but could be enhanced with
capability-based matching in the future.

---

### P1-4: Dynamic Composition Engine — PASS

The parser correctly decomposes natural language into all five IDD primitives
via LLM.

- [x] **P1-4a:** `parser.py` takes a `prompt: str`, calls an LLM provider with a JSON schema system prompt, and returns a `Decomposition` dataclass containing intent, trigger, agents, context, behaviors, and confidence.
- [x] **P1-4b:** Agent names are extracted from `coordinator.config["agents"].keys()` and presented to the LLM as a comma-separated list. The LLM selects agents by name.
- [x] **P1-4c:** Decomposition flows through decoupled building blocks: parser tool decomposes, reporter hook renders plan, confirmation hook gates, compiler tool produces YAML. The LLM orchestrates the flow. The five-step pipeline is also available as the hand-authored `idd-full-cycle.yaml` recipe with blocking approval gates between stages.

**Note:** There is no post-LLM validation that returned agent names match the
available list. The LLM receives the list in its prompt and is expected to pick
from it, but a programmatic check could be added for defense-in-depth.

**Cross-cutting feature:** The `GrammarState` registered as `idd.grammar_state`
enables the grammar-inject hook to provide the LLM with current decomposition
state (intent, criteria, progress, corrections) on every turn via ephemeral
system context injection.

---

### P1-5: Key Module References — PASS

Referenced modules are available transitively through the foundation bundle.

- [x] **P1-5a:** tool-delegate (tool-task) available via `amplifier-foundation` include in `bundle.md`.
- [x] **P1-5b:** tool-mcp available via the same transitive include.
- [x] **P1-5c:** Scheduling confirmed as external (cron, CI, manual invocation). No built-in scheduler, as documented in the spec.

---

### P1-6: Context Injection During Correction — PASS

The ephemeral injection mechanism is correctly implemented. The correction pipeline
has structural components in place with clearly defined wiring points.

- [x] **P1-6a:** Grammar-inject hook uses `action="inject_context"` with `ephemeral=True` on every `prompt:submit` event. Injection is per-turn — never added to permanent conversation history. Zero uses of `add_message()` or `set_messages()` in module source code.
- [x] **P1-6b:** Grammar state injection is human-readable structured text (`[IDD GRAMMAR STATE]` header with Intent, Success Criteria, Status, Corrections sections), not `json.dumps`. This is a deliberate design choice — human-readable text is more useful in LLM system context.
- [x] **P1-6c:** Correction data structures exist: `CorrectionRecord` dataclass, `GrammarState.corrections` list. The confirmation hook produces `user_correction` data. The grammar-inject hook reads and displays the last 3 corrections.

**Wiring gap:** The connecting code between the confirmation hook's
`user_correction` output and `GrammarState.corrections` is not yet written.
Similarly, `hooks.emit("idd:correction", ...)` is not yet called from any module.
The event recorder listens for it and the reporter has a handler ready. See
"Event Infrastructure" section below for the full picture.

---

### P1-8: Hook Priorities — PASS

Confirmed from three independent sources: `behaviors/idd-core.yaml` config,
module code defaults, and actual `hooks.register()` calls.

- [x] **P1-8a:** Priorities: Grammar injection at 3, confirmation at 7, event emission at 10, reporter at 15.
- [x] **P1-8b:** Grammar injection is pipeline-modifying (`action="inject_context"`). Event emission and reporter are non-blocking observers (`action="continue"`). Confirmation gate returns `action="ask_user"` with a 15-second timeout defaulting to allow.
- [x] **P1-8c:** All hook handlers wrap logic in try/except and return `action="continue"` on failure — a bug in an IDD hook never crashes the orchestrator.

---

## P2 — Address Before Publishing as Open Spec

### P2-1: Testing Strategy — DEFERRED

A test suite exists (216 tests, all passing) covering parser, grammar, compiler,
hooks, and tool mount/execute. No formal testing strategy document.

---

### P2-2: Security Considerations — DEFERRED

Not addressed. No prompt injection mitigations, privilege escalation guards, or
context leakage controls specific to IDD.

---

### P2-3: Governance and Procedural Requirements — PASS

Exemplary kernel hygiene.

- [x] **P2-3a:** Only `amplifier-bundle-idd` repo affected. Zero changes to `amplifier-core`.
- [x] **P2-3b:** All modules use conditional imports with `try/except ImportError` guards, enabling standalone testing without the Amplifier runtime.

---

### P2-4: Concurrency and Session Isolation — DEFERRED

No explicit concurrency controls (no locks, no session-keyed state). Implicit
per-session isolation via instance-per-coordinator pattern — each `mount()` creates
new tool/hook instances with their own `GrammarState`. Likely sufficient for
single-session usage but not formally addressed.

---

### P2-5: Error Propagation — DEFERRED

Error propagation from tool failures to Grammar state is unimplemented. Errors are
caught locally with defensive try/except and fallback behavior (e.g.,
`_fallback_decomposition`). `GrammarState.status` supports `"failed"` but it is
never written to. No `tool:error` events are captured by any IDD hook.

---

### P2-6: Nested Bundle Compatibility — DEFERRED

The implementation follows standard bundle composition patterns (`includes:` with
namespace prefixes, `idd:` resource references). No explicit design, code, or
testing for nested-inclusion scenarios. Potential concerns: tool name collisions,
hook priority conflicts, capability namespace overlap.

---

### P2-7: Capability Registration — PARTIALLY ADDRESSED

The spec envisioned callable-service capabilities (`idd.parse`, `idd.report`,
`idd.correct`). The implementation registered shared-state capabilities instead,
fitting the tool + hooks architecture:

| Capability | Registered By | Type | Purpose |
|------------|--------------|------|---------|
| `idd.grammar_state` | `IDDDecomposeTool.__init__` | Mutable `GrammarState` | Cross-module state (consumed by grammar-inject hook, compile tool) |
| `idd.event_log` | `hooks-idd-events` mount | In-memory event list | Observability (inspectable by modules, dashboards, tests) |

The callable-service pattern is unnecessary given the tool-based design where
functionality is already accessible as LLM-callable tools.

---

## Verification Matrix

| # | Item | Auditor | Status |
|---|------|---------|--------|
| P0-1 | No coordinator.mount("agents") misuse | core-expert | PASS |
| P0-2 | Recipe compilation pipeline | foundation-expert | PASS |
| P0-3 | Behaviors vs hooks distinction | amplifier-expert | PASS |
| P1-1 | Agent definition format | amplifier-expert | PASS |
| P1-4 | Dynamic composition engine | foundation-expert | PASS |
| P1-5 | Key module references | amplifier-expert | PASS |
| P1-6 | Context injection during correction | core-expert | PASS |
| P1-8 | Hook priorities | core-expert | PASS |
| P2-1 | Testing strategy | all | DEFERRED |
| P2-2 | Security considerations | all | DEFERRED |
| P2-3 | Governance / procedural | amplifier-expert | PASS |
| P2-4 | Concurrency / isolation | core-expert | DEFERRED |
| P2-5 | Error propagation | core-expert | DEFERRED |
| P2-6 | Nested bundle compatibility | foundation-expert | DEFERRED |
| P2-7 | Capability registration | core-expert | PARTIALLY ADDRESSED |

**Totals: 11 PASS, 5 DEFERRED, 1 PARTIALLY ADDRESSED**

---

## Event Infrastructure

Six IDD events are registered across the hook modules. Currently only
`idd:intent_parsed` is actively emitted. The remaining five have listeners and
handlers fully built, ready for a future execution layer.

| Event | Listener | Reporter Handler | Confirmation Handler | Emitted? |
|-------|----------|-----------------|---------------------|----------|
| `idd:intent_parsed` | events hook | — | — | Yes (decompose tool) |
| `idd:primitive_matched` | events hook | — | — | Not yet |
| `idd:composition_ready` | events hook | composition report | confirmation gate | Not yet |
| `idd:correction` | events hook | correction report | — | Not yet |
| `idd:progress` | events hook | progress report | — | Not yet |
| `idd:intent_resolved` | events hook | resolution report | — | Not yet |

---

## Retired Items

The following checklist items validated spec claims about a custom IDD orchestrator
that wraps `loop-streaming`. The implementation uses tools + hooks on the standard
orchestrator instead, making these items inapplicable. They are retained here for
traceability.

| Original # | Item | Why Retired |
|------------|------|-------------|
| P1-2 | IDD orchestrator wraps inner orchestrator | No custom orchestrator exists. Module type is `"tool"`, not `"orchestrator"`. |
| P1-3 | Grammar state propagation to child sessions | No child sessions. All IDD tools operate in the parent session. Grammar state shared via `idd.grammar_state` capability. |
| P1-7 | Orchestrator return value as `str` | No custom orchestrator. Tools return `ToolResult` per standard tool protocol. `idd:intent_resolved` listener is pre-built but not yet emitted. |

---

## Recommended Next Actions

1. **Wire the correction pipeline** — connect confirmation hook `user_correction` to `GrammarState.corrections` and emit `idd:correction`.
2. **Emit remaining events** — add `idd:composition_ready` after decomposition and `idd:intent_resolved` when appropriate.
3. **Add post-LLM agent name validation** — verify returned agent names exist in the available list.
4. **Add `foreach`/`while_condition` to compiler** — if recipe iteration is needed.
5. **Address P2 deferred items** — testing strategy, security, concurrency, error propagation, nested bundles.
